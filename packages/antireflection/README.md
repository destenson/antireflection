
## Antireflection for TypeScript: create your types from your metadata

**TypeScript version 2.2 or later is required**

```typescript
import * as ar from 'antireflection';

const pointType = ar.object({ // this is ordinary object initializer
    x: ar.number,  // ar.number (and ar.string) are just objects defined in antireflection.ts
    y: ar.number
});

type Point = ar.Type<typeof pointType>;

// it's the same as type Point = {x: number, y: number};
// but now you have its description at runtime:
// pointType.p() returns an object with Point type properties

// so, for example, you can check the type at run time:

const errors = ar.check(pointType, {x: 'a'});
console.dir(errors);
// x: expected number, got string
// y: expected number, got undefined
```

### nested objects are supported

```typescript
const circleType = ar.object({
    center: pointType,
    radius: ar.number
});

type Circle = ar.Type<typeof circleType>;
// same as type Circle = {center: Point, radius: number};
```

Circular structures are **not** supported - TypeScript infers `any` type for an object that is
"referenced directly or indirectly in its own initializer", which does not allow to derive a type from its value.

### arrays are supported

```typescript
const polygonType = ar.object({
    points: ar.array(pointType)
});

type Polygon = ar.Type<typeof polygonType>;
// the same as type Polygon = {points: Point[]};
```

### optional properties are supported, sort of

```typescript
const labeledPointType = ar.object({
   ...pointType.p(), // use object spread to reuse properties defined for other types
   label: ar.optional(ar.string)
});

type LabeledPoint = ar.Type<typeof labeledPointType>;
// same as type LabeledPoint = Point & {label: string | undefined};
```

However, optional properties **must be present** in direct object initialization,
all you can do is to assign `undefined` to them. The workaround is to use
`ar.create()` function which accepts two arguments: type descriptor and initial value,
which can have optional properties omitted:

```typescript
const p = ar.create(labeledPointType, {x: 0, y: 0}); // ok
// const p1: LabeledPoint = {x: 0, y: 0}; // does not compile: Property 'label' is missing
const p2: LabeledPoint = {x: 0, y: 0, label: undefined}; // also ok
```

### extensions: how to add your own types


### antireflection internals: types for properties and type descriptors

In `antireflection.ts`, `ar.object` is defined as generic function

```typescript
 export function object<P extends Properties>(p: P)
```
The type of its parameter is defined as mapped type that has specific object properties mapped to their type descriptors.

It extends `Properties` type

```typescript
export type Properties = {
    [N in string]: TypeDescriptor;
};
```
where TypeDescriptor is the supertype for all representable types.

`ar.number`, `ar.string`, `ar.array`, `ar.object` and `ar.optional` all return values typed as appropriate instances of some type that extends TypeDescriptor.

When you define object type
```typescript
const pointType = ar.object({x: ar.number, y: ar.string});
```
its type descriptor, `pointType`, has a method named `p()` (short for properties) that returns appropriate instance of `Properties` type describing properties of that object.

### antireflection internals: structural recursion

There are three functions exported: `ar.mapSource`, `ar.mapTarget` and `ar.Reduce` that take a function, a type descriptor and a value;
and apply the function to all properties, sub-properties and sub-elements of a value as described by type descriptor.

```typescript
function mapSource<D extends TypeDescriptor>(f: SourceMapper, v: Type<D>, d: D, path: Path = []): Value {
```

`mapSource` throws if value `v` does not conform to type descriptor `d`, and returns resulting value as generated by mapping function `f`.


```typescript
function mapTarget<D extends TypeDescriptor>(f: TargetMapper, v: Value, d: D, path: Path = []): Type<D> {
```

`mapTarget` takes any value v, applies mapping function `f` to it and throws if resulting value does not conform to type descriptor `d`.

```typescript
function reduce<R>(f: Reducer<R>, v: Value, r: R, d: TypeDescriptor, path: Path = []): R {
```

`reduce` throws if value `v` does not conform to type descriptor `d`, and applies reducing function `f` according to the structure described by `d`.


As an example, here is implementation of `ar.typedClone` and `ar.create`:

```typescript
export function typedClone<D extends TypeDescriptor>(d: D, v: Type<D>): Type<D> {
    return mapSource(({v}) => v, v, d);
}

export type PartialObject<P extends Properties> = {[N in keyof P]?: Type<P[N]>};

// NOTE: throws if anything non-optional in P is absent in o
export function create<P extends Properties>(d: OD<P>, o: PartialObject<P>): O<P> {
    return mapTarget(({v}) => v, o, d);
}
```

### extending type descriptors

You can easily add your own information to type descriptors. It's also relatively easy to have it type-checked.

For example, [antireflection-default](https://github.com/fictitious/antireflection/tree/master/packages/antireflection-default/README.md)
extension adds type-checked optional default value to object properties and exports its own version of `ar.create`
that takes into account default values (and `ar.object` that typechecks default values).

It can be used like this:

```typescript
import * as ar from 'antireflection';
import * as ard from 'antireflection-default';

const pointType = ard.object({
    x: {...ar.number, defaultValue: 0},
    y: {...ar.number, defaultValue: 0}
});

type Point = ar.Type<typeof pointType>;

const p = ard.create(pointType, {});
// will throw at runtime for non-optional properties with no value and no default

```

Here is complete source code for `antireflection-default`:

```typescript
import * as ar from 'antireflection';

export type DefaultValues<P extends ar.Properties> = P & {[N in keyof P]: ar.TypeDescriptor & {defaultValue?: ar.Type<P[N]>}};

export function object<P extends ar.Properties>(p: DefaultValues<P>): ar.OD<DefaultValues<P>> {
    return {t:'object', p: () => p, _p: [], ...ar.objectMethods}
}

export function create<P extends ar.Properties>(d: ar.OD<DefaultValues<P>>, o: ar.PartialObject<P>) {
    return ar.mapTarget(f, o, d);

    function f(args: ar.TargetMapperArgs & {d: ar.TypeDescriptor & {defaultValue?: ar.Value}}): ar.Value {
        return args.v !== undefined ? args.v : args.d.defaultValue;
    }
}
```



